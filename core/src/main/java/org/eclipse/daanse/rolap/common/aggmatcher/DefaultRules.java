/*
 * This software is subject to the terms of the Eclipse Public License v1.0
 * Agreement, available at the following URL:
 * http://www.eclipse.org/legal/epl-v10.html.
 * You must accept the terms of that agreement to use this software.
 *
 * Copyright (C) 2005-2005 Julian Hyde
 * Copyright (C) 2005-2017 Hitachi Vantara and others
 * All Rights Reserved.
 *
 * ---- All changes after Fork in 2023 ------------------------
 *
 * Project: Eclipse daanse
 *
 * Copyright (c) 2023 Contributors to the Eclipse Foundation.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors after Fork in 2023:
 *   SmartCity Jena - initial
 */
package org.eclipse.daanse.rolap.common.aggmatcher;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.daanse.rolap.aggmatch.jaxb.AggRule;
import org.eclipse.daanse.rolap.aggmatch.jaxb.AggRules;
import org.eclipse.daanse.rolap.aggmatch.jaxb.CharCaseEnum;
import org.eclipse.daanse.rolap.aggmatch.jaxb.FactCountMatch;
import org.eclipse.daanse.rolap.aggmatch.jaxb.FactCountMatchRef;
import org.eclipse.daanse.rolap.aggmatch.jaxb.ForeignKeyMatch;
import org.eclipse.daanse.rolap.aggmatch.jaxb.IgnoreMap;
import org.eclipse.daanse.rolap.aggmatch.jaxb.LevelMap;
import org.eclipse.daanse.rolap.aggmatch.jaxb.LevelMapRef;
import org.eclipse.daanse.rolap.aggmatch.jaxb.MeasureMap;
import org.eclipse.daanse.rolap.aggmatch.jaxb.MeasureMapRef;
import org.eclipse.daanse.rolap.aggmatch.jaxb.Regex;
import org.eclipse.daanse.rolap.aggmatch.jaxb.TableMatch;
import org.eclipse.daanse.rolap.aggmatch.jaxb.TableMatchRef;
import org.eclipse.daanse.rolap.common.RolapStar;
import org.eclipse.daanse.rolap.recorder.ListRecorder;
import org.eclipse.daanse.rolap.recorder.MessageRecorder;
import org.eclipse.daanse.rolap.recorder.RecorderException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Container for the default aggregate recognition rules.
 * It is generated by parsing the default rule xml information found
 * in the AggregateRules value which normally is
 * a resource in the jar file (but can be a url).
 *
 * It is a singleton since it is used to recognize tables independent of
 * database connection (each {@link org.eclipse.daanse.rolap.common.RolapCatalog} uses the same
 * instance).
 *
 * @author Richard M. Emberson
 */
public class DefaultRules {

    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultRules.class);
    private final static String missingDefaultAggRule = "There is no default aggregate recognition rule with tag ''{0}''.";
    private final static String couldNotLoadDefaultAggregateRules = "Could not load default aggregate rules ''{0}''.";

    /**
     * There is a single instance of the {@link DefaultRecognizer} and the
     * {@link DefaultRules} class is a container of that instance.
     */
    public static synchronized DefaultRules getInstance() {
        if (instance == null) {

            AggRules aggrules = new AggRules();

            TableMatch tm=new TableMatch();
            tm.setId("ta");
            tm.setPretemplate("agg_.+_");

            aggrules.getTableMatches().add(tm);

            FactCountMatch fcm=new FactCountMatch();
            fcm.setId("fca");
            aggrules.getFactCountMatches().add(fcm);

            LevelMap lvlMap=new LevelMap();
            lvlMap.setId("lxx");
            aggrules.getLevelMaps().add(lvlMap);

            Regex regexLog=new Regex();
            regexLog.setId("logical");
            regexLog.setCharCase(CharCaseEnum.LOWER);
            regexLog.setTemplate("${hierarchy_name}_${level_name}");

            Regex regexMixed=new Regex();
            regexMixed.setId("mixed");
            regexMixed.setCharCase(CharCaseEnum.LOWER);
            regexMixed.setTemplate("${hierarchy_name}_${level_column_name}");

            Regex regexUsage=new Regex();
            regexUsage.setId("usage");
            regexUsage.setCharCase(CharCaseEnum.EXACT);
            regexUsage.setTemplate("${usage_prefix}${level_column_name}");

            Regex regexPhysical=new Regex();
            regexPhysical.setId("physical");
            regexPhysical.setCharCase(CharCaseEnum.EXACT);
            regexPhysical.setTemplate("${level_column_name}");

            lvlMap.setRegexs(List.of(regexLog,regexMixed,regexUsage,regexPhysical));

            MeasureMap measMap=new MeasureMap();
            measMap.setId("mxx");

            Regex mmRegexLogical=new Regex();
            mmRegexLogical.setId("logical");
            mmRegexLogical.setCharCase(CharCaseEnum.LOWER);
            mmRegexLogical.setTemplate("${measure_name}");

//            Sometimes a base fact table foreign key is also used in a
//            measure. This Regex is used to match such usages in
//            the aggregate table. Using such a match only makes sense
//            if one prior to attempting to match knows that the
//            column in question in the base fact table is indeed used
//            as a measure (for this matches any foreign key).

            Regex mmRegexForeignKey=new Regex();
            mmRegexForeignKey.setId("foreignkey");
            mmRegexForeignKey.setCharCase(CharCaseEnum.EXACT);
            mmRegexForeignKey.setTemplate("${measure_column_name}");

            Regex mmRegexPhysical=new Regex();
            mmRegexPhysical.setId("physical");
            mmRegexPhysical.setCharCase(CharCaseEnum.EXACT);
            mmRegexPhysical.setTemplate("${measure_column_name}_${aggregate_name}");

            measMap.setRegexs(List.of(mmRegexLogical,mmRegexForeignKey,mmRegexPhysical));

            aggrules.getMeasureMaps().add(measMap);

            AggRule aggRDefault=new AggRule();
            aggRDefault.setTag("default");

            FactCountMatchRef factCountMatchRef=new FactCountMatchRef();
            factCountMatchRef.setRefId("fca");
            aggRDefault.setFactCountMatchRef(factCountMatchRef);

            ForeignKeyMatch foreignKeyMatch=new ForeignKeyMatch();
            foreignKeyMatch.setId("fka");
            aggRDefault.setForeignKeyMatch(foreignKeyMatch);

            TableMatchRef tableMatchRef=new TableMatchRef();
            tableMatchRef.setRefId("ta");
            aggRDefault.setTableMatchRef(tableMatchRef);

            LevelMapRef levelMapRef=new LevelMapRef();
            levelMapRef.setRefId("lxx");
            aggRDefault.setLevelMapRef(levelMapRef);

            MeasureMapRef measureMapRef=new MeasureMapRef();
            measureMapRef.setRefId("mxx");
            aggRDefault.setMeasureMapRef(measureMapRef);


            aggrules.getAggRules().add(aggRDefault);
            // validate the DefaultDef.AggRules object
            ListRecorder reclists = new ListRecorder();
            try {
                aggrules.validate(reclists);
            } catch (RecorderException e) {
                // ignore
            }

            reclists.logWarningMessage(LOGGER);
            reclists.logErrorMessage(LOGGER);

            if (reclists.hasErrors()) {
                reclists.throwRTException();
            }

            DefaultRules rules = new DefaultRules(aggrules, "default");
            rules.setTag("default");
            instance = rules;
        }
        return instance;
    }
    private static DefaultRules instance = null;

    /*
    static {
        // When the value of the AggregateRules property is changed, force
        // system to reload the DefaultRules.
        // There is no need to provide equals/hashCode methods for this
        // Trigger since it is a singleton and is never removed.
        Trigger trigger =
            new Trigger() {
                @Override
				public boolean isPersistent() {
                    return true;
                }
                @Override
				public int phase() {
                    return Trigger.PRIMARY_PHASE;
                }
                @Override
				public void execute(Property property, String value) {
                    synchronized (DefaultRules.class) {
                        DefaultRules oldInstance = DefaultRules.instance;
                        DefaultRules.instance = null;

                        DefaultRules newInstance = null;
                        Exception ex = null;
                        try {
                            newInstance = DefaultRules.getInstance();
                        } catch (Exception e) {
                            ex = e;
                        }
                        if (ex != null) {
                            DefaultRules.instance = oldInstance;

                            throw new Trigger.VetoRT(ex);

                        } else if (newInstance == null) {
                            DefaultRules.instance = oldInstance;

                            String msg =
                                mres.FailedCreateNewDefaultAggregateRules.str(
                                    property.getPath(),
                                    value);
                            throw new Trigger.VetoRT(msg);

                        } else {
                            instance = newInstance;
                        }
                    }
                }
            };

        final MondrianProperties properties = MondrianProperties.instance();
        properties.AggregateRules.addTrigger(trigger);
        properties.AggregateRuleTag.addTrigger(trigger);
    }
    */


    private final AggRules rules;
    private final Map<String, Recognizer.Matcher> factToPattern;
    private final Map<String, Recognizer.Matcher> foreignKeyMatcherMap;
    private Recognizer.Matcher ignoreMatcherMap;
    private Recognizer.Matcher factCountMatcher;
    private String tag;

    private DefaultRules(final AggRules rules, String aggregateRuleTag) {
        this.rules = rules;
        this.factToPattern = new HashMap<>();
        this.foreignKeyMatcherMap = new HashMap<>();
        this.tag = aggregateRuleTag;
    }

    public void validate(MessageRecorder msgRecorder) {
        rules.validate(msgRecorder);
    }

    /**
     * Sets the name (tag) of this rule.
     *
     * @param tag
     */
    private void setTag(final String tag) {
        this.tag = tag;
    }

    /**
     * Gets the tag of this rule (this is the value of the
     * AggregateRuleTag property).
     */
    public String getTag() {
        return this.tag;
    }


    /**
     * Returns the {@link AggRule} whose
     * tag equals this rule's tag.
     */
    public AggRule getAggRule() {
        return getAggRule(getTag());
    }

    /**
     * Returns the {@link AggRule} whose
     * tag equals the parameter tag, or null if not found.
     *
     * @param tag
     * @return the AggRule with tag value equal to tag parameter, or null.
     */
    public AggRule getAggRule(final String tag) {
        return this.rules.getAggRule(tag);
    }

    /**
     * Gets the {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for this
     * tableName.
     *
     * @param tableName
     */
    public Recognizer.Matcher getTableMatcher(final String tableName) {
        Recognizer.Matcher matcher = factToPattern.get(tableName);
        if (matcher == null) {
            // get default AggRule
            AggRule rule = getAggRule();
            TableMatch tableMatch = rule.getTableMatch();
            matcher = tableMatch.getMatcher(tableName);
            factToPattern.put(tableName, matcher);
        }
        return matcher;
    }

    /**
     * Gets the {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for the
     * fact count column.
     */
    public Recognizer.Matcher getIgnoreMatcher() {
        if (ignoreMatcherMap == null) {
            // get default AggRule
            AggRule rule = getAggRule();
            IgnoreMap ignoreMatch = rule.getIgnoreMap();
            if (ignoreMatch == null) {
                ignoreMatcherMap = new Recognizer.Matcher() {
                    @Override
					public boolean matches(String name) {
                        return false;
                    }
                };
            } else {
                ignoreMatcherMap = ignoreMatch.getMatcher();
            }
        }
        return ignoreMatcherMap;
    }

    /**
     * Gets the {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for
     * columns that should be ignored.
     *
     * @return the {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for
     * columns that should be ignored.
     */
    public Recognizer.Matcher getFactCountMatcher() {
        if (factCountMatcher == null) {
            // get default AggRule
            AggRule rule = getAggRule();
            FactCountMatch factCountMatch =
                rule.getFactCountMatch();
            factCountMatcher = factCountMatch.getMatcher();
        }
        return factCountMatcher;
    }

    /**
     * Gets the {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for this
     * foreign key column name.
     *
     * @param foreignKeyName Name of a foreign key column
     */
    public Recognizer.Matcher getForeignKeyMatcher(String foreignKeyName) {
        Recognizer.Matcher matcher =
            foreignKeyMatcherMap.get(foreignKeyName);
        if (matcher == null) {
            // get default AggRule
            AggRule rule = getAggRule();
            ForeignKeyMatch foreignKeyMatch =
                rule.getForeignKeyMatch();
            matcher = foreignKeyMatch.getMatcher(foreignKeyName);
            foreignKeyMatcherMap.put(foreignKeyName, matcher);
        }
        return matcher;
    }

    /**
     * Returns true if this candidate aggregate table name "matches" the
     * factTableName.
     *
     * @param factTableName Name of the fact table
     * @param name candidate aggregate table name
     */
    public boolean matchesTableName(
        final String factTableName,
        final String name)
    {
        Recognizer.Matcher matcher = getTableMatcher(factTableName);
        return matcher.matches(name);
    }

    /**
     * Creates a {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for the
     * given measure name (symbolic name), column name and aggregate name
     * (sum, count, etc.).
     */
    public Recognizer.Matcher getMeasureMatcher(
        final String measureName,
        final String measureColumnName,
        final String aggregateName)
    {
        AggRule rule = getAggRule();
        return rule.getMeasureMap().getMatcher(
            measureName,
            measureColumnName,
            aggregateName);
    }

    /**
     * Gets a {@link org.eclipse.daanse.rolap.common.aggmatcher.Recognizer.Matcher} for a given
     * level's hierarchy's name, level name and column name.
     */
    public Recognizer.Matcher getLevelMatcher(
        final String usagePrefix,
        final String hierarchyName,
        final String levelName,
        final String levelColumnName)
    {
        AggRule rule = getAggRule();
        return rule.getLevelMap().getMatcher(
                usagePrefix,
                hierarchyName,
                levelName,
                levelColumnName);
    }

    /**
     * Uses the {@link DefaultRecognizer} Recognizer to determine if the
     * given aggTable's columns all match upto the dbFactTable's columns (where
     * present) making the column usages as a result.
     */
    public boolean columnsOK(
        final RolapStar star,
        final JdbcSchema.Table dbFactTable,
        final JdbcSchema.Table aggTable,
        final MessageRecorder msgRecorder)
    {
        Recognizer cb = new DefaultRecognizer(
            this,
            star,
            dbFactTable,
            aggTable,
            msgRecorder);
        return cb.check();
    }
}
